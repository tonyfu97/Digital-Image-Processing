{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Digital Image Processing with C++ : Study Notes This website includes my study notes for the book Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, and Barra. Please note that this website does not include the book's content, except for the code snippets used. If you're interested in more details, you can purchase the book here . I am not affiliated with the authors or the publisher in any way. I simply enjoy the book and want to share my notes with others. While I have some background in image processing, I have attempted to make my notes beginner-friendly. I have included things that I personally found to need more explanation or clarification. I hope you find them useful. Disclaimer All intellectual property rights related to the book, including content, images, and related materials, are owned by the authors and publisher. The information provided on this website is intended for educational purposes and personal use only, and should not be considered a substitute for purchasing the book. Introduction I relied on OpenCV for my image processing needs. Though powerful, setting it up on a new machine was always cumbersome, requiring complex installation and linking processes. Plus, OpenCV's extensive set of features often felt overwhelming, making it difficult to manage and understand specific algorithm implementations. That's when I discovered CImg\u2014a refreshingly simple library that encapsulates everything into a single header file . This approach means I can copy the header into my project and start using it immediately, without the hassle. I have also always wanted to learn more about the inner workings and design patterns of image processing libraries. CImg's simplicity makes it a great candidate for this purpose. This repository will document my journey and the insights I gain along the way. References Primary reference : Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra CImg Library Principles of Digital Image Processing series by Burger & Burge (2009, 2013)","title":"Home"},{"location":"#digital-image-processing-with-c-study-notes","text":"This website includes my study notes for the book Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, and Barra. Please note that this website does not include the book's content, except for the code snippets used. If you're interested in more details, you can purchase the book here . I am not affiliated with the authors or the publisher in any way. I simply enjoy the book and want to share my notes with others. While I have some background in image processing, I have attempted to make my notes beginner-friendly. I have included things that I personally found to need more explanation or clarification. I hope you find them useful.","title":"Digital Image Processing with C++ : Study Notes"},{"location":"#disclaimer","text":"All intellectual property rights related to the book, including content, images, and related materials, are owned by the authors and publisher. The information provided on this website is intended for educational purposes and personal use only, and should not be considered a substitute for purchasing the book.","title":"Disclaimer"},{"location":"#introduction","text":"I relied on OpenCV for my image processing needs. Though powerful, setting it up on a new machine was always cumbersome, requiring complex installation and linking processes. Plus, OpenCV's extensive set of features often felt overwhelming, making it difficult to manage and understand specific algorithm implementations. That's when I discovered CImg\u2014a refreshingly simple library that encapsulates everything into a single header file . This approach means I can copy the header into my project and start using it immediately, without the hassle. I have also always wanted to learn more about the inner workings and design patterns of image processing libraries. CImg's simplicity makes it a great candidate for this purpose. This repository will document my journey and the insights I gain along the way.","title":"Introduction"},{"location":"#references","text":"Primary reference : Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra CImg Library Principles of Digital Image Processing series by Burger & Burge (2009, 2013)","title":"References"},{"location":"01_getting_started/","text":"Getting Started with the CImg Library - Learning Reflection Author : Tony Fu Date : August 18, 2023 Device : MacBook Pro 16-inch, Late 2021 (M1 Pro) Reference : Chapter 2.1 - 2.2 Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra 1. Installing XQuartz (X11 on macOS) Yes, I lied. I said you only need to include the CImg.h header file to get started. But that's not entirely true. You also need to install the X11 library, which is used to display images. The X11 library is used to display images. It is an open-source effort to develop a version of the X.Org X Window System that runs on macOS. You can download the latest version of XQuartz here . Follow the instructions to install it on your machine. Because X11 is often installs in a non-standard location (/opt/X11). This means that the compiler and linker may not automatically look in this location when trying to find the X11 libraries and include files. So, we need to modified the ~/.zshrc file (or whatever shell you're using) to add the following lines: # XQuartz (for CImg) export LIBRARY_PATH=/opt/X11/lib:$LIBRARY_PATH export CPATH=/opt/X11/include:$CPATH This effectively includes the X11 library in the compiler's search path. Don't forget to restart the shell or execute source ~/.zshrc to apply the changes to the current shell. 2. Installing the PNG Library If you want to read and save images in .png format, as demonstrated in the upcoming example, you'll need to install the libpng library. You can install it using Homebrew with the following command: brew install libpng You won't need to modify any environment variables for libpng . When you install libpng using Homebrew (or another standard package manager), it places the library and include files in standard locations that the compiler and linker already recognize. 3. First Program To display an image using the CImg library, include the CImg.h header file and use the CImgDisplay class. Here's a simple example first_code.cpp : #define cimg_use_png #include \"CImg.h\" using namespace cimg_library; int main() { CImg<unsigned char> img(\"../images/lighthouse.png\"); img.display(\"Lighthouse\"); return 0; } The CImg class is a template class that represents an image. The template parameter specifies the type of the image pixels. In this case, the image is a color image with unsigned 8-bit integer pixels. The CImg class has a constructor that takes a filename as input and loads the image from the file. The display() method of the CImg class displays the image in a window. The first argument is the title of the window. Here the macro cimg_use_png is used to specify that the libpng library should be used to read and write images in .png format. This gives us a peak into how we can customize the CImg library to suit our needs. To compile the program, you need to link the X11 and png library. Here is the command I used: g++ -o first_code first_code.cpp -lX11 -lpthread -lpng The -lpthread option links the pthread library. The pthread library is used to create threads, which is needed by the CImg library. To run the program, do the following: ./first_code 4. Visual Studio Code Configuration If you're coding inside Visual Studio Code like I am, you might see a red squiggly line under #include \"CImg.h\" , accompanied by the complaint Cannot open source file \"X11/Xlib.h\" (dependency of \"CImg.h\") . Here's how to fix this issue: Open the Command Palette by pressing Cmd+Shift+P on a Mac or Ctrl+Shift+P on Windows/Linux. Type \"C/C++\" in the Command Palette, and then select \"Edit Configurations (JSON)\" from the dropdown list. This action will open the c_cpp_properties.json file directly. Add the following line to the includePath array: \"includePath\": [ \"${workspaceFolder}/**\", \"/opt/X11/include/**\" // Add this line ], Save the file. The red squiggly line should now disappear.","title":"1. Getting Started"},{"location":"01_getting_started/#getting-started-with-the-cimg-library-learning-reflection","text":"Author : Tony Fu Date : August 18, 2023 Device : MacBook Pro 16-inch, Late 2021 (M1 Pro) Reference : Chapter 2.1 - 2.2 Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra","title":"Getting Started with the CImg Library - Learning Reflection"},{"location":"01_getting_started/#1-installing-xquartz-x11-on-macos","text":"Yes, I lied. I said you only need to include the CImg.h header file to get started. But that's not entirely true. You also need to install the X11 library, which is used to display images. The X11 library is used to display images. It is an open-source effort to develop a version of the X.Org X Window System that runs on macOS. You can download the latest version of XQuartz here . Follow the instructions to install it on your machine. Because X11 is often installs in a non-standard location (/opt/X11). This means that the compiler and linker may not automatically look in this location when trying to find the X11 libraries and include files. So, we need to modified the ~/.zshrc file (or whatever shell you're using) to add the following lines: # XQuartz (for CImg) export LIBRARY_PATH=/opt/X11/lib:$LIBRARY_PATH export CPATH=/opt/X11/include:$CPATH This effectively includes the X11 library in the compiler's search path. Don't forget to restart the shell or execute source ~/.zshrc to apply the changes to the current shell.","title":"1. Installing XQuartz (X11 on macOS)"},{"location":"01_getting_started/#2-installing-the-png-library","text":"If you want to read and save images in .png format, as demonstrated in the upcoming example, you'll need to install the libpng library. You can install it using Homebrew with the following command: brew install libpng You won't need to modify any environment variables for libpng . When you install libpng using Homebrew (or another standard package manager), it places the library and include files in standard locations that the compiler and linker already recognize.","title":"2. Installing the PNG Library"},{"location":"01_getting_started/#3-first-program","text":"To display an image using the CImg library, include the CImg.h header file and use the CImgDisplay class. Here's a simple example first_code.cpp : #define cimg_use_png #include \"CImg.h\" using namespace cimg_library; int main() { CImg<unsigned char> img(\"../images/lighthouse.png\"); img.display(\"Lighthouse\"); return 0; } The CImg class is a template class that represents an image. The template parameter specifies the type of the image pixels. In this case, the image is a color image with unsigned 8-bit integer pixels. The CImg class has a constructor that takes a filename as input and loads the image from the file. The display() method of the CImg class displays the image in a window. The first argument is the title of the window. Here the macro cimg_use_png is used to specify that the libpng library should be used to read and write images in .png format. This gives us a peak into how we can customize the CImg library to suit our needs. To compile the program, you need to link the X11 and png library. Here is the command I used: g++ -o first_code first_code.cpp -lX11 -lpthread -lpng The -lpthread option links the pthread library. The pthread library is used to create threads, which is needed by the CImg library. To run the program, do the following: ./first_code","title":"3. First Program"},{"location":"01_getting_started/#4-visual-studio-code-configuration","text":"If you're coding inside Visual Studio Code like I am, you might see a red squiggly line under #include \"CImg.h\" , accompanied by the complaint Cannot open source file \"X11/Xlib.h\" (dependency of \"CImg.h\") . Here's how to fix this issue: Open the Command Palette by pressing Cmd+Shift+P on a Mac or Ctrl+Shift+P on Windows/Linux. Type \"C/C++\" in the Command Palette, and then select \"Edit Configurations (JSON)\" from the dropdown list. This action will open the c_cpp_properties.json file directly. Add the following line to the includePath array: \"includePath\": [ \"${workspaceFolder}/**\", \"/opt/X11/include/**\" // Add this line ], Save the file. The red squiggly line should now disappear.","title":"4. Visual Studio Code Configuration"},{"location":"02_block_decomposition/","text":"Block Decomposition - Learning Reflection Author : Tony Fu Date : August 18, 2023 Device : MacBook Pro 16-inch, Late 2021 (M1 Pro) Reference : Chapter 2.3 - 2.7 Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra 1. CImg Template Class The CImg library is a template-based image manipulation library, and its template argument specifies the pixel type. By default, if you don't specify the template argument, it's instantiated with float . So when you declare an image like this: CImg<> img(\"image.png\"); It is equivalent to: CImg<float> img(\"image.png\"); You can specify a different type if you want, such as unsigned char , int , etc. But if you simply use CImg<> , then it defaults to using float . CImg<T> is a part of the CImg library, a popular, open-source C++ toolkit that facilitates the creation and manipulation of images. The templated class CImg<T> can represent images with pixels of different types (e.g., float , int , etc.). Below are some commonly used constructors for CImg<T> : Default Constructor : CImg<T>(); This constructs an empty image. Constructor with Dimensions : CImg<T>(const unsigned int width, const unsigned int height, const unsigned int depth = 1, const unsigned int spectrum = 1, const T& value = 0); * `width`: Width of the image. * `height`: Height of the image. * `depth`: Depth of the image (default is 1 for 2D images). * `spectrum`: Number of channels (e.g., 3 for RGB image). * `value`: Initial value for all pixels. Copy Constructor : CImg<T>(const CImg<T>& img); Constructs a copy of the given image img . Constructor from File : CImg<T>(const char* filename); Constructs an image by reading from a file specified by filename . Constructor from Data : CImg<T>(const T* data, const unsigned int width, const unsigned int height, const unsigned int depth = 1, const unsigned int spectrum = 1, const bool shared = false); * `data`: Pointer to pixel data. * `width`, `height`, `depth`, `spectrum`: Same as above. * `shared`: If `true`, the data is shared with the original pointer without making a separate copy. Constructor from Expression : CImg<T>(const char* expression, const char* variable_name = 0, const T& variable_value = 0, const char* variable_name1 = 0, const T& variable_value1 = 0); This constructor creates an image from a mathematical expression, allowing for variable substitutions. 2. Reading Command-Line Parameters The cimg_usage() and cimg_option() functions are used to handle command-line arguments. Here's a brief description of each function: cimg_usage(const char *const format, ...) : This function is typically used to print a description of your program when it's invoked from the command line. cimg_option(const char *const opt, type_def variable, const char *const format, ...) : This function is a command-line option parser. It's used to handle options passed to your program when it's invoked from the command line. Here's a breakdown of the parameters: opt : the name of the command-line option. variable : the default value that will be assigned to the variable if the corresponding command-line option is not provided. format : a string that may contain a description of what the option does (this will be printed if a specific help option is invoked, like --help ). Here's a simple example showing how you might use these functions: #include \"CImg.h\" int main(int argc, char **argv) { cimg_usage(\"My simple program that does XYZ.\"); int my_option1 = cimg_option(\"-o1\", 0, \"An optional parameter that affects behavior.\"); int my_option2 = cimg_option(\"-o2\", 99, \"Another optional parameter that affects behavior.\"); // Rest of the program } If the user runs the program with the options, like ./my_program -o1 5 , the my_option1 variable will be set to 5 , and the my_option2 variable will be set to the default value of 99 . If they run the program with the --help option, they will see the usage string followed by the options descriptions. 3. Get vs. Non-Get Methods in Image Processing with CImg In image processing using CImg, it's really helpful to know whether a method is going to give you a new object (a get method) or change the one you already have (a non-get method). CImg has both types for most of its methods: Get Methods : These create a new object with the changes you want, leaving the one you started with the same. Like CImg<float>::get_blur() , which makes a new blurred image but doesn't touch the original. Non-get Methods : These change the object you call them on and usually give you back a reference to that changed object. For example, CImg<float>::blur() changes the image and gives you back a reference to it. Here's an example to show how this works: CImg<> lum = img.get_norm().blur(sigma).normalize(0, 255); In this code, get_norm makes a new image (make it gray-scale by taking the L2-norm of the RGB channel), and blur and normalize change it and give you back references. This way of doing things makes it easy to chain operations together and save memory. Resutls: Original Image Luminance Image 4. Gradient Magnitude Computation Gradient is computed using the get_gradient() method. The gradient is computed using the centered finite differences by default. We will discuss the spatial filtering in Chapter 5. The method returns a CImgList object, which is a list of images in the order you specify. In this case, we want the gradient in the x and y directions, so we specify \"xy\" as the argument. CImgList<> grad = lum.get_gradient(\"xy\"); Then we compute the gradient magnitude using the following formula: \\|\\nabla I\\| = \\sqrt{G_x^2 + G_y^2} CImg<> normGrad = (grad[0].get_sqr() += grad[1].get_sqr()).sqrt(); Notice the use of the \"non-get\" += operator, which prevents the creation of an unnecessary temporary image. Results: Gradient Magnitude Image 5. Block Decomposition See Algorithm 1 in the book for the pseudocode. Here's my breakdown: Accessing the Current Block : The loop iterates through a list of blocks ( blocks ), where each block is represented by a CImg<int> object containing four integers representing the coordinates of the top-left and bottom-right corners of the block (x0, y0) and (x1, y1). (Yes, CImg can be used as 1D vectors using CImg<int>::vector() . Checking Conditions : For each block, the code checks two conditions: (a) If the maximum value of the normGrad image, when cropped to the current block, is greater than a given threshold. (b) If both the width and height of the block are greater than 8. Splitting the Block : If both conditions are met, the block is divided into four equal parts. The new blocks are created by calculating the midpoint of the original block (xc, yc) and using these coordinates to define the four new blocks. Updating the List of Blocks : The four new blocks are added to the blocks list using the move_to() method to avoid creating unnecessary copies. The original block is then removed from the list using the remove() method. Continuing Iteration : If the conditions are not met, the loop simply moves on to the next block by incrementing the index l . 6. Loop Iteration in CImg The following macros greatly simplify writing loops that iterate over various parts of an image: cimg_for(img,ptr,T) : Iterates over all pixels of an image. cimg_for(img, ptr, T) { // Do something with ptr, a pointer to the pixel value. } cimg_forX(img,x) : Iterates over the width of an image. cimg_forX(img, x) { // x is the x-coordinate, ranging from 0 to img.width() - 1. } For macro cimg_forX(img,x) , you do not need to declare x as an integer before using it in the loop. The macro itself takes care of that. If there is already a variable named x in the same scope where you're using this macro, you can place the code inside a different scope. cimg_forY(img,y) : Iterates over the height of an image. cimg_forY(img, y) { // y is the y-coordinate, ranging from 0 to img.height() - 1. } cimg_forZ(img,z) : Iterates over the depth of an image (for 3D images). cimg_forZ(img, z) { // z is the z-coordinate, ranging from 0 to img.depth() - 1. } cimg_forC(img,c) : Iterates over the channels (spectrum) of an image. cimg_forC(img, c) { // c is the channel index, ranging from 0 to img.spectrum() - 1. } cimg_forXY(img,x,y) : Iterates over both the width and height of an image. cimg_forXY(img, x, y) { // Do something with x and y coordinates. } cimg_forXYZ(img,x,y,z) : Iterates over width, height, and depth of a 3D image. cimg_forXYZ(img, x, y, z) { // Do something with x, y, and z coordinates. } cimg_forXYZC(img,x,y,z,c) : Iterates over all dimensions, including channels. cimg_forXYZC(img, x, y, z, c) { // Do something with x, y, z coordinates and channel c. } 7. Drawing Blocks blocks is a vector of (x0, y0, x1, y1) coordinates. In the following code, we iterate through each block. We use get_crop() and resize() the cropped image to 1x1 pixels, which is the average color of the block. Then we draw a rectangle using the draw_rectangle() method. // Rendering of the decomposition. CImg<unsigned char> res(img.width(), img.height(), 1, 3, 0); CImg<int> coords(img.width(), img.height(), 1, 4, 0); cimglist_for(blocks, l) { CImg<int> &block = blocks[l]; int x0 = block[0], y0 = block[1], x1 = block[2], y1 = block[3]; CImg<unsigned char> color = img.get_crop(x0, y0, x1, y1).resize(1, 1, 1, 3, 2); res.draw_rectangle(x0, y0, x1, y1, color.data(), 1); coords.draw_rectangle(x0, y0, x1, y1, block.data()); } There are two CImg objects here: res : This is the final image that will be displayed. It is initialized to all black pixels. coords : This maps each pixel to the block it belongs to. It will be used later for user interaction. // Adding black borders. res.mul(1 - (res.get_shift(1, 1, 0, 0, 0) - res).norm().cut(0, 1)); This above is a clever way to add black borders: Part 1: Edge Detection The first part of the expression is a kind of high-pass edge detection filter that calculates the difference between adjacent pixels in the image, thereby emphasizing sharp changes or edges. The expression for this part is: \\text{mask}(x, y) = \\left(1 - \\min\\left(1, \\max\\left(0, \\|res(x, y) - res(x - 1, y - 1)\\|\\right)\\right)\\right) Here, \\|res(x, y) - res(x - 1, y - 1)\\| calculates the difference between adjacent pixels. By using the min and max functions, this difference is clipped to the range [0, 1] , with 0 representing no change (no edge) and 1 representing a large change (an edge). res mask Part 2: Multiplication The second part of the expression involves multiplying the original pixel value with the edge value obtained in Part 1. This has the effect of enhancing the detected edges in the image. The expression for this part is: \\text{result}(x, y) = res(x, y) \\cdot \\text{mask}(x, y) Block Decomposition The book also propose two other ways to render the borders: CImg<unsigned char>::fill() and cimg_for3x3 . 8. GUI The CImgDisplay class is used to create a window and display an image. It has the following constructor: CImgDisplay disp(const CImg<T>& img, const char* title = 0, const int normalization_type = 3); The normalization type is used to specify how the image is normalized when displayed. The following table shows the different options: Normalization Value Description 0 No normalization applied. 1 Automatic linear normalization to the [0, 255] range. 2 A one-time linear normalization with parameters calculated at the first display. These are then reused for subsequent images in the same window. Ideal for preserving consistent gray levels. 3 Default automatic mode, with behavior depending on the type. The following code creates a window and displays the image res : // Start the interactive viewer. CImgDisplay disp(res, \"CImg Tutorial: Block Decomposition\", 0); unsigned char white[] = {255, 255, 255}, black[] = {0, 0, 0}; while (!disp.is_closed() && !disp.is_keyESC()) { int x = disp.mouse_x(), y = disp.mouse_y(); if (x >= 0 && y >= 0) { // Get the coordinates of the block under the mouse position. int x0 = coords(x, y, 0), y0 = coords(x, y, 1), x1 = coords(x, y, 2), y1 = coords(x, y, 3), xc = (x0 + x1) / 2, yc = (y0 + y1) / 2; // Get the block and its gradient. CImg<unsigned char> pImg = img.get_crop(x0, y0, x1, y1).resize(128, 128, 1, 3, 1), pGrad = normGrad.get_crop(x0, y0, x1, y1).resize(128, 128, 1, 3, 1).normalize(0, 255).map(CImg<unsigned char>::hot_LUT256()); // Display the block and its gradient. (+res). draw_text(10, 3, \"X, Y = %d, %d\", white, 0, 1, 24, x, y). draw_rectangle(x0, y0, x1, y1, black, 0.25f). draw_line(74, 109, xc, yc, white, 0.75, 0xCCCCCCCC). draw_line(74, 264, xc, yc, white, 0.75, 0xCCCCCCCC). draw_rectangle(7, 32, 140, 165, white). draw_rectangle(7, 197, 140, 330, white). draw_image(10, 35, pImg). draw_image(10, 200, pGrad). display(disp); } disp.wait(); // Wait for an user event if (disp.is_resized()) disp.resize(disp); } Read a book for more details. Note that (+res) is a trick used to make a copy of the image res without creating a new object.","title":"2. Block Decomposition"},{"location":"02_block_decomposition/#block-decomposition-learning-reflection","text":"Author : Tony Fu Date : August 18, 2023 Device : MacBook Pro 16-inch, Late 2021 (M1 Pro) Reference : Chapter 2.3 - 2.7 Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra","title":"Block Decomposition - Learning Reflection"},{"location":"02_block_decomposition/#1-cimg-template-class","text":"The CImg library is a template-based image manipulation library, and its template argument specifies the pixel type. By default, if you don't specify the template argument, it's instantiated with float . So when you declare an image like this: CImg<> img(\"image.png\"); It is equivalent to: CImg<float> img(\"image.png\"); You can specify a different type if you want, such as unsigned char , int , etc. But if you simply use CImg<> , then it defaults to using float . CImg<T> is a part of the CImg library, a popular, open-source C++ toolkit that facilitates the creation and manipulation of images. The templated class CImg<T> can represent images with pixels of different types (e.g., float , int , etc.). Below are some commonly used constructors for CImg<T> : Default Constructor : CImg<T>(); This constructs an empty image. Constructor with Dimensions : CImg<T>(const unsigned int width, const unsigned int height, const unsigned int depth = 1, const unsigned int spectrum = 1, const T& value = 0); * `width`: Width of the image. * `height`: Height of the image. * `depth`: Depth of the image (default is 1 for 2D images). * `spectrum`: Number of channels (e.g., 3 for RGB image). * `value`: Initial value for all pixels. Copy Constructor : CImg<T>(const CImg<T>& img); Constructs a copy of the given image img . Constructor from File : CImg<T>(const char* filename); Constructs an image by reading from a file specified by filename . Constructor from Data : CImg<T>(const T* data, const unsigned int width, const unsigned int height, const unsigned int depth = 1, const unsigned int spectrum = 1, const bool shared = false); * `data`: Pointer to pixel data. * `width`, `height`, `depth`, `spectrum`: Same as above. * `shared`: If `true`, the data is shared with the original pointer without making a separate copy. Constructor from Expression : CImg<T>(const char* expression, const char* variable_name = 0, const T& variable_value = 0, const char* variable_name1 = 0, const T& variable_value1 = 0); This constructor creates an image from a mathematical expression, allowing for variable substitutions.","title":"1. CImg Template Class"},{"location":"02_block_decomposition/#2-reading-command-line-parameters","text":"The cimg_usage() and cimg_option() functions are used to handle command-line arguments. Here's a brief description of each function: cimg_usage(const char *const format, ...) : This function is typically used to print a description of your program when it's invoked from the command line. cimg_option(const char *const opt, type_def variable, const char *const format, ...) : This function is a command-line option parser. It's used to handle options passed to your program when it's invoked from the command line. Here's a breakdown of the parameters: opt : the name of the command-line option. variable : the default value that will be assigned to the variable if the corresponding command-line option is not provided. format : a string that may contain a description of what the option does (this will be printed if a specific help option is invoked, like --help ). Here's a simple example showing how you might use these functions: #include \"CImg.h\" int main(int argc, char **argv) { cimg_usage(\"My simple program that does XYZ.\"); int my_option1 = cimg_option(\"-o1\", 0, \"An optional parameter that affects behavior.\"); int my_option2 = cimg_option(\"-o2\", 99, \"Another optional parameter that affects behavior.\"); // Rest of the program } If the user runs the program with the options, like ./my_program -o1 5 , the my_option1 variable will be set to 5 , and the my_option2 variable will be set to the default value of 99 . If they run the program with the --help option, they will see the usage string followed by the options descriptions.","title":"2. Reading Command-Line Parameters"},{"location":"02_block_decomposition/#3-get-vs-non-get-methods-in-image-processing-with-cimg","text":"In image processing using CImg, it's really helpful to know whether a method is going to give you a new object (a get method) or change the one you already have (a non-get method). CImg has both types for most of its methods: Get Methods : These create a new object with the changes you want, leaving the one you started with the same. Like CImg<float>::get_blur() , which makes a new blurred image but doesn't touch the original. Non-get Methods : These change the object you call them on and usually give you back a reference to that changed object. For example, CImg<float>::blur() changes the image and gives you back a reference to it. Here's an example to show how this works: CImg<> lum = img.get_norm().blur(sigma).normalize(0, 255); In this code, get_norm makes a new image (make it gray-scale by taking the L2-norm of the RGB channel), and blur and normalize change it and give you back references. This way of doing things makes it easy to chain operations together and save memory. Resutls: Original Image Luminance Image","title":"3. Get vs. Non-Get Methods in Image Processing with CImg"},{"location":"02_block_decomposition/#4-gradient-magnitude-computation","text":"Gradient is computed using the get_gradient() method. The gradient is computed using the centered finite differences by default. We will discuss the spatial filtering in Chapter 5. The method returns a CImgList object, which is a list of images in the order you specify. In this case, we want the gradient in the x and y directions, so we specify \"xy\" as the argument. CImgList<> grad = lum.get_gradient(\"xy\"); Then we compute the gradient magnitude using the following formula: \\|\\nabla I\\| = \\sqrt{G_x^2 + G_y^2} CImg<> normGrad = (grad[0].get_sqr() += grad[1].get_sqr()).sqrt(); Notice the use of the \"non-get\" += operator, which prevents the creation of an unnecessary temporary image. Results: Gradient Magnitude Image","title":"4. Gradient Magnitude Computation"},{"location":"02_block_decomposition/#5-block-decomposition","text":"See Algorithm 1 in the book for the pseudocode. Here's my breakdown: Accessing the Current Block : The loop iterates through a list of blocks ( blocks ), where each block is represented by a CImg<int> object containing four integers representing the coordinates of the top-left and bottom-right corners of the block (x0, y0) and (x1, y1). (Yes, CImg can be used as 1D vectors using CImg<int>::vector() . Checking Conditions : For each block, the code checks two conditions: (a) If the maximum value of the normGrad image, when cropped to the current block, is greater than a given threshold. (b) If both the width and height of the block are greater than 8. Splitting the Block : If both conditions are met, the block is divided into four equal parts. The new blocks are created by calculating the midpoint of the original block (xc, yc) and using these coordinates to define the four new blocks. Updating the List of Blocks : The four new blocks are added to the blocks list using the move_to() method to avoid creating unnecessary copies. The original block is then removed from the list using the remove() method. Continuing Iteration : If the conditions are not met, the loop simply moves on to the next block by incrementing the index l .","title":"5. Block Decomposition"},{"location":"02_block_decomposition/#6-loop-iteration-in-cimg","text":"The following macros greatly simplify writing loops that iterate over various parts of an image: cimg_for(img,ptr,T) : Iterates over all pixels of an image. cimg_for(img, ptr, T) { // Do something with ptr, a pointer to the pixel value. } cimg_forX(img,x) : Iterates over the width of an image. cimg_forX(img, x) { // x is the x-coordinate, ranging from 0 to img.width() - 1. } For macro cimg_forX(img,x) , you do not need to declare x as an integer before using it in the loop. The macro itself takes care of that. If there is already a variable named x in the same scope where you're using this macro, you can place the code inside a different scope. cimg_forY(img,y) : Iterates over the height of an image. cimg_forY(img, y) { // y is the y-coordinate, ranging from 0 to img.height() - 1. } cimg_forZ(img,z) : Iterates over the depth of an image (for 3D images). cimg_forZ(img, z) { // z is the z-coordinate, ranging from 0 to img.depth() - 1. } cimg_forC(img,c) : Iterates over the channels (spectrum) of an image. cimg_forC(img, c) { // c is the channel index, ranging from 0 to img.spectrum() - 1. } cimg_forXY(img,x,y) : Iterates over both the width and height of an image. cimg_forXY(img, x, y) { // Do something with x and y coordinates. } cimg_forXYZ(img,x,y,z) : Iterates over width, height, and depth of a 3D image. cimg_forXYZ(img, x, y, z) { // Do something with x, y, and z coordinates. } cimg_forXYZC(img,x,y,z,c) : Iterates over all dimensions, including channels. cimg_forXYZC(img, x, y, z, c) { // Do something with x, y, z coordinates and channel c. }","title":"6. Loop Iteration in CImg"},{"location":"02_block_decomposition/#7-drawing-blocks","text":"blocks is a vector of (x0, y0, x1, y1) coordinates. In the following code, we iterate through each block. We use get_crop() and resize() the cropped image to 1x1 pixels, which is the average color of the block. Then we draw a rectangle using the draw_rectangle() method. // Rendering of the decomposition. CImg<unsigned char> res(img.width(), img.height(), 1, 3, 0); CImg<int> coords(img.width(), img.height(), 1, 4, 0); cimglist_for(blocks, l) { CImg<int> &block = blocks[l]; int x0 = block[0], y0 = block[1], x1 = block[2], y1 = block[3]; CImg<unsigned char> color = img.get_crop(x0, y0, x1, y1).resize(1, 1, 1, 3, 2); res.draw_rectangle(x0, y0, x1, y1, color.data(), 1); coords.draw_rectangle(x0, y0, x1, y1, block.data()); } There are two CImg objects here: res : This is the final image that will be displayed. It is initialized to all black pixels. coords : This maps each pixel to the block it belongs to. It will be used later for user interaction. // Adding black borders. res.mul(1 - (res.get_shift(1, 1, 0, 0, 0) - res).norm().cut(0, 1)); This above is a clever way to add black borders:","title":"7. Drawing Blocks"},{"location":"02_block_decomposition/#part-1-edge-detection","text":"The first part of the expression is a kind of high-pass edge detection filter that calculates the difference between adjacent pixels in the image, thereby emphasizing sharp changes or edges. The expression for this part is: \\text{mask}(x, y) = \\left(1 - \\min\\left(1, \\max\\left(0, \\|res(x, y) - res(x - 1, y - 1)\\|\\right)\\right)\\right) Here, \\|res(x, y) - res(x - 1, y - 1)\\| calculates the difference between adjacent pixels. By using the min and max functions, this difference is clipped to the range [0, 1] , with 0 representing no change (no edge) and 1 representing a large change (an edge). res mask","title":"Part 1: Edge Detection"},{"location":"02_block_decomposition/#part-2-multiplication","text":"The second part of the expression involves multiplying the original pixel value with the edge value obtained in Part 1. This has the effect of enhancing the detected edges in the image. The expression for this part is: \\text{result}(x, y) = res(x, y) \\cdot \\text{mask}(x, y) Block Decomposition The book also propose two other ways to render the borders: CImg<unsigned char>::fill() and cimg_for3x3 .","title":"Part 2: Multiplication"},{"location":"02_block_decomposition/#8-gui","text":"The CImgDisplay class is used to create a window and display an image. It has the following constructor: CImgDisplay disp(const CImg<T>& img, const char* title = 0, const int normalization_type = 3); The normalization type is used to specify how the image is normalized when displayed. The following table shows the different options: Normalization Value Description 0 No normalization applied. 1 Automatic linear normalization to the [0, 255] range. 2 A one-time linear normalization with parameters calculated at the first display. These are then reused for subsequent images in the same window. Ideal for preserving consistent gray levels. 3 Default automatic mode, with behavior depending on the type. The following code creates a window and displays the image res : // Start the interactive viewer. CImgDisplay disp(res, \"CImg Tutorial: Block Decomposition\", 0); unsigned char white[] = {255, 255, 255}, black[] = {0, 0, 0}; while (!disp.is_closed() && !disp.is_keyESC()) { int x = disp.mouse_x(), y = disp.mouse_y(); if (x >= 0 && y >= 0) { // Get the coordinates of the block under the mouse position. int x0 = coords(x, y, 0), y0 = coords(x, y, 1), x1 = coords(x, y, 2), y1 = coords(x, y, 3), xc = (x0 + x1) / 2, yc = (y0 + y1) / 2; // Get the block and its gradient. CImg<unsigned char> pImg = img.get_crop(x0, y0, x1, y1).resize(128, 128, 1, 3, 1), pGrad = normGrad.get_crop(x0, y0, x1, y1).resize(128, 128, 1, 3, 1).normalize(0, 255).map(CImg<unsigned char>::hot_LUT256()); // Display the block and its gradient. (+res). draw_text(10, 3, \"X, Y = %d, %d\", white, 0, 1, 24, x, y). draw_rectangle(x0, y0, x1, y1, black, 0.25f). draw_line(74, 109, xc, yc, white, 0.75, 0xCCCCCCCC). draw_line(74, 264, xc, yc, white, 0.75, 0xCCCCCCCC). draw_rectangle(7, 32, 140, 165, white). draw_rectangle(7, 197, 140, 330, white). draw_image(10, 35, pImg). draw_image(10, 200, pGrad). display(disp); } disp.wait(); // Wait for an user event if (disp.is_resized()) disp.resize(disp); } Read a book for more details. Note that (+res) is a trick used to make a copy of the image res without creating a new object.","title":"8. GUI"},{"location":"03_point_processing/","text":"Point Processing Transformations - Learning Reflection Author : Tony Fu Date : August 19, 2023 Device : MacBook Pro 16-inch, Late 2021 (M1 Pro) Reference : Chapter 3 Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra 1. Mathematical Transformations 1.0. Orignal Image 1.1. Exponential Transformations CImg<> expImg = lum.get_exp()/50; 1.2. Square Root Transformations CImg<> sqrtImg = lum.get_sqrt()*10; 1.3. Logarithmic Transformations CImg<> logImg = (2 + lum.get_abs()).log(); 1.4 Cube Transformations CImg<> cubeImg = lum.get_pow(3); 2. Bitwise Transformations 2.0. Orignal Images 2.1. Bitwise AND CImg<unsigned char> img_and = img1 & img2; If you have two 8-bit pixels, one with the value 0101 (5 in decimal) and the other with 1010 (10 in decimal), then the bitwise AND operation between these two pixels would give you 0000 (0 in decimal). 2.2. Bitwise OR CImg<unsigned char> img_or = img1 | img2; 2.3. Bitwise XOR CImg<unsigned char> img_xor = img1 ^ img2; As we seen in the above example, bitwise operations might seem somewhat abstract when applied to images (5 & 10 = 0. What?), but they are actually quite useful in in specific contexts: Masking : If you have a binary mask where certain pixels are set to 1 and others are set to 0, you can use the bitwise AND operation with an image to \"mask\" or isolate those areas. Steganography or Watermarking : Bitwise operations might be used to embed or extract information within an image. By operating at the bit level, you can hide data within the least significant bits of an image in a way that's almost visually imperceptible. Refer to Code 3.3 in the book for an example. Thresholding : If you have two binary images representing different thresholded features, the bitwise AND can be used to find the overlapping areas between those features. 3. Histogram Equalization","title":"3. Point Processing Transformations"},{"location":"03_point_processing/#point-processing-transformations-learning-reflection","text":"Author : Tony Fu Date : August 19, 2023 Device : MacBook Pro 16-inch, Late 2021 (M1 Pro) Reference : Chapter 3 Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library by Tschumperl\u00e9, Tilmant, Barra","title":"Point Processing Transformations - Learning Reflection"},{"location":"03_point_processing/#1-mathematical-transformations","text":"","title":"1. Mathematical Transformations"},{"location":"03_point_processing/#10-orignal-image","text":"","title":"1.0. Orignal Image"},{"location":"03_point_processing/#11-exponential-transformations","text":"CImg<> expImg = lum.get_exp()/50;","title":"1.1. Exponential Transformations"},{"location":"03_point_processing/#12-square-root-transformations","text":"CImg<> sqrtImg = lum.get_sqrt()*10;","title":"1.2. Square Root Transformations"},{"location":"03_point_processing/#13-logarithmic-transformations","text":"CImg<> logImg = (2 + lum.get_abs()).log();","title":"1.3. Logarithmic Transformations"},{"location":"03_point_processing/#14-cube-transformations","text":"CImg<> cubeImg = lum.get_pow(3);","title":"1.4 Cube Transformations"},{"location":"03_point_processing/#2-bitwise-transformations","text":"","title":"2. Bitwise Transformations"},{"location":"03_point_processing/#20-orignal-images","text":"","title":"2.0. Orignal Images"},{"location":"03_point_processing/#21-bitwise-and","text":"CImg<unsigned char> img_and = img1 & img2; If you have two 8-bit pixels, one with the value 0101 (5 in decimal) and the other with 1010 (10 in decimal), then the bitwise AND operation between these two pixels would give you 0000 (0 in decimal).","title":"2.1. Bitwise AND"},{"location":"03_point_processing/#22-bitwise-or","text":"CImg<unsigned char> img_or = img1 | img2;","title":"2.2. Bitwise OR"},{"location":"03_point_processing/#23-bitwise-xor","text":"CImg<unsigned char> img_xor = img1 ^ img2; As we seen in the above example, bitwise operations might seem somewhat abstract when applied to images (5 & 10 = 0. What?), but they are actually quite useful in in specific contexts: Masking : If you have a binary mask where certain pixels are set to 1 and others are set to 0, you can use the bitwise AND operation with an image to \"mask\" or isolate those areas. Steganography or Watermarking : Bitwise operations might be used to embed or extract information within an image. By operating at the bit level, you can hide data within the least significant bits of an image in a way that's almost visually imperceptible. Refer to Code 3.3 in the book for an example. Thresholding : If you have two binary images representing different thresholded features, the bitwise AND can be used to find the overlapping areas between those features.","title":"2.3. Bitwise XOR"},{"location":"03_point_processing/#3-histogram-equalization","text":"","title":"3. Histogram Equalization"},{"location":"appendix_1/","text":"Math Expressions in CImg's Fill Method This page provides a guide to using mathematical expressions within the CImg<unsigned char>::fill() method of the CImg library. Syntax and Operators Mathematical expressions can include the following: Basic arithmetic: + , - , * , / , % Trigonometric functions: sin , cos , tan , etc. Logarithmic functions: log , exp , etc. Variables I : Represents the current pixel value. For example, I*2 would double the intensity of every pixel. J(x, y) : Refers to the neighboring pixel values at relative coordinates (x, y) x , y , z , c : Represents the coordinates of the current pixel. Constants pi Conditional Expressions You can use conditional expressions like condition ? value_if_true : value_if_false . Boolean Logic Use logical operators like && (AND), || (OR), and ! (NOT) for conditional logic, and comparison operators ( == , != , < , <= , > , >= ) are also available. Examples 0. Original Image 1. Doubling the Intensity of an Image CImg<unsigned char> img(\"image.jpg\"); img.fill(\"I*2\", true); 2. Inverting an Image CImg<unsigned char> img(\"image.jpg\"); img.fill(\"255-I\", true); 3. Spiral Effect CImg<unsigned char> img(\"image.jpg\"); img_spiral.fill(\"(x*y)%500\",true); 4. Conditional Operations CImg<unsigned char> img(\"image.jpg\"); img.fill(\"I*(I!=J(1,0) || I!=J(0,1)?0:1)\", true);","title":"Appendix 1 - Math Expressions in CImg's Fill Method"},{"location":"appendix_1/#math-expressions-in-cimgs-fill-method","text":"This page provides a guide to using mathematical expressions within the CImg<unsigned char>::fill() method of the CImg library.","title":"Math Expressions in CImg's Fill Method"},{"location":"appendix_1/#syntax-and-operators","text":"Mathematical expressions can include the following: Basic arithmetic: + , - , * , / , % Trigonometric functions: sin , cos , tan , etc. Logarithmic functions: log , exp , etc.","title":"Syntax and Operators"},{"location":"appendix_1/#variables","text":"I : Represents the current pixel value. For example, I*2 would double the intensity of every pixel. J(x, y) : Refers to the neighboring pixel values at relative coordinates (x, y) x , y , z , c : Represents the coordinates of the current pixel.","title":"Variables"},{"location":"appendix_1/#constants","text":"pi","title":"Constants"},{"location":"appendix_1/#conditional-expressions","text":"You can use conditional expressions like condition ? value_if_true : value_if_false .","title":"Conditional Expressions"},{"location":"appendix_1/#boolean-logic","text":"Use logical operators like && (AND), || (OR), and ! (NOT) for conditional logic, and comparison operators ( == , != , < , <= , > , >= ) are also available.","title":"Boolean Logic"},{"location":"appendix_1/#examples","text":"","title":"Examples"},{"location":"appendix_1/#0-original-image","text":"","title":"0. Original Image"},{"location":"appendix_1/#1-doubling-the-intensity-of-an-image","text":"CImg<unsigned char> img(\"image.jpg\"); img.fill(\"I*2\", true);","title":"1. Doubling the Intensity of an Image"},{"location":"appendix_1/#2-inverting-an-image","text":"CImg<unsigned char> img(\"image.jpg\"); img.fill(\"255-I\", true);","title":"2. Inverting an Image"},{"location":"appendix_1/#3-spiral-effect","text":"CImg<unsigned char> img(\"image.jpg\"); img_spiral.fill(\"(x*y)%500\",true);","title":"3. Spiral Effect"},{"location":"appendix_1/#4-conditional-operations","text":"CImg<unsigned char> img(\"image.jpg\"); img.fill(\"I*(I!=J(1,0) || I!=J(0,1)?0:1)\", true);","title":"4. Conditional Operations"}]}
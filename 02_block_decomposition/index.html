<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Tony Fu" /><link rel="canonical" href="https://tonyfu97.github.io/Digital-Image-Processing/02_block_decomposition/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>2. Block Decomposition - Digital Image Processing Notes</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "2. Block Decomposition";
        var mkdocs_page_input_path = "02_block_decomposition.md";
        var mkdocs_page_url = "/Digital-Image-Processing/02_block_decomposition/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/django.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-274394082"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-274394082');
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Digital Image Processing Notes
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../01_getting_started/">1. Getting Started</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">2. Block Decomposition</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#1-cimg-template-class">1. CImg Template Class</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2-reading-command-line-parameters">2. Reading Command-Line Parameters</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#3-get-vs-non-get-methods-in-image-processing-with-cimg">3. Get vs. Non-Get Methods in Image Processing with CImg</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#4-gradient-magnitude-computation">4. Gradient Magnitude Computation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#5-block-decomposition">5. Block Decomposition</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#6-loop-iteration-in-cimg">6. Loop Iteration in CImg</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#7-drawing-blocks">7. Drawing Blocks</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#part-1-edge-detection">Part 1: Edge Detection</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#part-2-multiplication">Part 2: Multiplication</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#8-gui">8. GUI</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../03_point_processing/">3. Point Processing Transformations</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../appendix_1/">Appendix 1 - Math Expressions in CImg's Fill Method</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Digital Image Processing Notes</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>2. Block Decomposition</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/tonyfu97/Digital-Image-Processing/blob/master/docs/02_block_decomposition.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="block-decomposition-learning-reflection">Block Decomposition - Learning Reflection</h1>
<p><strong>Author</strong>: Tony Fu<br />
<strong>Date</strong>: August 18, 2023<br />
<strong>Device</strong>: MacBook Pro 16-inch, Late 2021 (M1 Pro)<br />
<strong>Reference</strong>: Chapter 2.3 - 2.7 <a href="https://www.amazon.com/Digital-Image-Processing-Implementing-Algorithms/dp/1032347538"><em>Digital Image Processing with C++: Implementing Reference Algorithms with the CImg Library</em> by Tschumperl√©, Tilmant, Barra</a></p>
<h2 id="1-cimg-template-class">1. <code>CImg</code> Template Class</h2>
<p>The <code>CImg</code> library is a template-based image manipulation library, and its template argument specifies the pixel type. By default, if you don't specify the template argument, it's instantiated with <code>float</code>.</p>
<p>So when you declare an image like this:</p>
<pre><code class="language-cpp">CImg&lt;&gt; img(&quot;image.png&quot;);
</code></pre>
<p>It is equivalent to:</p>
<pre><code class="language-cpp">CImg&lt;float&gt; img(&quot;image.png&quot;);
</code></pre>
<p>You can specify a different type if you want, such as <code>unsigned char</code>, <code>int</code>, etc. But if you simply use <code>CImg&lt;&gt;</code>, then it defaults to using <code>float</code>.</p>
<p><code>CImg&lt;T&gt;</code> is a part of the CImg library, a popular, open-source C++ toolkit that facilitates the creation and manipulation of images. The templated class <code>CImg&lt;T&gt;</code> can represent images with pixels of different types (e.g., <code>float</code>, <code>int</code>, etc.).</p>
<p>Below are some commonly used constructors for <a href="https://cimg.eu/reference/structcimg__library_1_1CImg.html"><code>CImg&lt;T&gt;</code></a>:</p>
<ul>
<li><strong>Default Constructor</strong>: </li>
</ul>
<pre><code class="language-cpp">CImg&lt;T&gt;();
</code></pre>
<p>This constructs an empty image.</p>
<ul>
<li><strong>Constructor with Dimensions</strong>:</li>
</ul>
<pre><code class="language-cpp">CImg&lt;T&gt;(const unsigned int width, const unsigned int height, const unsigned int depth = 1, const unsigned int spectrum = 1, const T&amp; value = 0);
</code></pre>
<pre><code>* `width`: Width of the image.
* `height`: Height of the image.
* `depth`: Depth of the image (default is 1 for 2D images).
* `spectrum`: Number of channels (e.g., 3 for RGB image).
* `value`: Initial value for all pixels.
</code></pre>
<ul>
<li><strong>Copy Constructor</strong>:</li>
</ul>
<pre><code class="language-cpp">CImg&lt;T&gt;(const CImg&lt;T&gt;&amp; img);
</code></pre>
<p>Constructs a copy of the given image <code>img</code>.</p>
<ul>
<li><strong>Constructor from File</strong>:</li>
</ul>
<pre><code class="language-cpp">CImg&lt;T&gt;(const char* filename);
</code></pre>
<p>Constructs an image by reading from a file specified by <code>filename</code>.</p>
<ul>
<li><strong>Constructor from Data</strong>:</li>
</ul>
<pre><code class="language-cpp">CImg&lt;T&gt;(const T* data, const unsigned int width, const unsigned int height, const unsigned int depth = 1, const unsigned int spectrum = 1, const bool shared = false);
</code></pre>
<pre><code>* `data`: Pointer to pixel data.
* `width`, `height`, `depth`, `spectrum`: Same as above.
* `shared`: If `true`, the data is shared with the original pointer without making a separate copy.
</code></pre>
<ul>
<li><strong>Constructor from Expression</strong>:</li>
</ul>
<pre><code class="language-cpp">CImg&lt;T&gt;(const char* expression, const char* variable_name = 0, const T&amp; variable_value = 0, const char* variable_name1 = 0, const T&amp; variable_value1 = 0);
</code></pre>
<p>This constructor creates an image from a mathematical expression, allowing for variable substitutions.</p>
<h2 id="2-reading-command-line-parameters">2. Reading Command-Line Parameters</h2>
<p>The <code>cimg_usage()</code> and <code>cimg_option()</code> functions are used to handle command-line arguments. Here's a brief description of each function:</p>
<ol>
<li>
<p><strong><code>cimg_usage(const char *const format, ...)</code>:</strong> This function is typically used to print a description of your program when it's invoked from the command line.</p>
</li>
<li>
<p><strong><code>cimg_option(const char *const opt, type_def variable, const char *const format, ...)</code>:</strong> This function is a command-line option parser. It's used to handle options passed to your program when it's invoked from the command line. Here's a breakdown of the parameters:</p>
</li>
<li><code>opt</code>: the name of the command-line option.</li>
<li><code>variable</code>:  the default value that will be assigned to the variable if the corresponding command-line option is not provided.</li>
<li><code>format</code>: a string that may contain a description of what the option does (this will be printed if a specific help option is invoked, like <code>--help</code>).</li>
</ol>
<p>Here's a simple example showing how you might use these functions:</p>
<pre><code class="language-cpp">#include &quot;CImg.h&quot;

int main(int argc, char **argv) {
    cimg_usage(&quot;My simple program that does XYZ.&quot;);
    int my_option1 = cimg_option(&quot;-o1&quot;, 0, &quot;An optional parameter that affects behavior.&quot;);
    int my_option2 = cimg_option(&quot;-o2&quot;, 99, &quot;Another optional parameter that affects behavior.&quot;);
    // Rest of the program
}
</code></pre>
<p>If the user runs the program with the options, like <code>./my_program -o1 5</code>, the <code>my_option1</code> variable will be set to <code>5</code>, and the <code>my_option2</code> variable will be set to the default value of <code>99</code>.</p>
<p>If they run the program with the <code>--help</code> option, they will see the usage string followed by the options descriptions.</p>
<h2 id="3-get-vs-non-get-methods-in-image-processing-with-cimg">3. Get vs. Non-Get Methods in Image Processing with CImg</h2>
<p>In image processing using CImg, it's really helpful to know whether a method is going to give you a new object (a get method) or change the one you already have (a non-get method). CImg has both types for most of its methods:</p>
<ul>
<li><strong>Get Methods</strong>: These create a new object with the changes you want, leaving the one you started with the same. Like <code>CImg&lt;float&gt;::get_blur()</code>, which makes a new blurred image but doesn't touch the original.</li>
<li><strong>Non-get Methods</strong>: These change the object you call them on and usually give you back a reference to that changed object. For example, <code>CImg&lt;float&gt;::blur()</code> changes the image and gives you back a reference to it.</li>
</ul>
<p>Here's an example to show how this works:</p>
<pre><code class="language-cpp">CImg&lt;&gt; lum = img.get_norm().blur(sigma).normalize(0, 255);
</code></pre>
<p>In this code, <code>get_norm</code> makes a new image (make it gray-scale by taking the L2-norm of the RGB channel), and <code>blur</code> and <code>normalize</code> change it and give you back references. This way of doing things makes it easy to chain operations together and save memory.</p>
<p><strong>Resutls:</strong></p>
<ul>
<li>
<p>Original Image
<img alt="lighthouse original" src="../images/lighthouse.png" /> </p>
</li>
<li>
<p>Luminance Image
<img alt="lighthouse lum" src="../results/02/lighthouse_lum.png" /></p>
</li>
</ul>
<h2 id="4-gradient-magnitude-computation">4. Gradient Magnitude Computation</h2>
<p>Gradient is computed using the <a href="https://cimg.eu/reference/structcimg__library_1_1CImg.html#a0f7d2161b942a08e4575451de817227d"><code>get_gradient()</code></a> method. The gradient is computed using the <em>centered finite differences</em> by default. We will discuss the spatial filtering in Chapter 5. The method returns a <code>CImgList</code> object, which is a list of images in the order you specify. In this case, we want the gradient in the x and y directions, so we specify <code>"xy"</code> as the argument.</p>
<pre><code class="language-cpp">CImgList&lt;&gt; grad = lum.get_gradient(&quot;xy&quot;);
</code></pre>
<p>Then we compute the gradient magnitude using the following formula:
<script type="math/tex; mode=display">
\|\nabla I\| = \sqrt{G_x^2 + G_y^2}
</script>
</p>
<pre><code class="language-cpp">CImg&lt;&gt; normGrad = (grad[0].get_sqr() += grad[1].get_sqr()).sqrt();
</code></pre>
<p>Notice the use of the "non-get" <code>+=</code> operator, which prevents the creation of an unnecessary temporary image.</p>
<p><strong>Results:</strong></p>
<ul>
<li>Gradient Magnitude Image
<img alt="lighthouse grad" src="../results/02/lighthouse_normGrad.png" /></li>
</ul>
<h2 id="5-block-decomposition">5. Block Decomposition</h2>
<p>See <strong>Algorithm 1</strong> in the book for the pseudocode. Here's my breakdown:</p>
<ol>
<li>
<p><strong>Accessing the Current Block</strong>: The loop iterates through a list of blocks (<code>blocks</code>), where each block is represented by a <code>CImg&lt;int&gt;</code> object containing four integers representing the coordinates of the top-left and bottom-right corners of the block (x0, y0) and (x1, y1). (Yes, <code>CImg</code> can be used as 1D vectors using <code>CImg&lt;int&gt;::vector()</code>.</p>
</li>
<li>
<p><strong>Checking Conditions</strong>: For each block, the code checks two conditions:
   (a) If the maximum value of the <code>normGrad</code> image, when cropped to the current block, is greater than a given threshold.
   (b) If both the width and height of the block are greater than 8.</p>
</li>
<li>
<p><strong>Splitting the Block</strong>: If both conditions are met, the block is divided into four equal parts. The new blocks are created by calculating the midpoint of the original block (xc, yc) and using these coordinates to define the four new blocks.</p>
</li>
<li>
<p><strong>Updating the List of Blocks</strong>: The four new blocks are added to the <code>blocks</code> list using the <code>move_to()</code> method to avoid creating unnecessary copies. The original block is then removed from the list using the <code>remove()</code> method.</p>
</li>
<li>
<p><strong>Continuing Iteration</strong>: If the conditions are not met, the loop simply moves on to the next block by incrementing the index <code>l</code>.</p>
</li>
</ol>
<h2 id="6-loop-iteration-in-cimg">6. Loop Iteration in CImg</h2>
<p>The following macros greatly simplify writing loops that iterate over various parts of an image:</p>
<ul>
<li><strong>cimg_for(img,ptr,T)</strong>: Iterates over all pixels of an image.</li>
</ul>
<pre><code class="language-cpp">cimg_for(img, ptr, T) {
    // Do something with ptr, a pointer to the pixel value.
}
</code></pre>
<ul>
<li><strong>cimg_forX(img,x)</strong>: Iterates over the width of an image.</li>
</ul>
<pre><code class="language-cpp">cimg_forX(img, x) {
    // x is the x-coordinate, ranging from 0 to img.width() - 1.
}
</code></pre>
<p>For macro <code>cimg_forX(img,x)</code>, you do not need to declare <code>x</code> as an integer before using it in the loop. The macro itself takes care of that. If there is already a variable named <code>x</code> in the same scope where you're using this macro, you can place the code inside a different scope.</p>
<ul>
<li><strong>cimg_forY(img,y)</strong>: Iterates over the height of an image.</li>
</ul>
<pre><code class="language-cpp">cimg_forY(img, y) {
    // y is the y-coordinate, ranging from 0 to img.height() - 1.
}
</code></pre>
<ul>
<li><strong>cimg_forZ(img,z)</strong>: Iterates over the depth of an image (for 3D images).</li>
</ul>
<pre><code class="language-cpp">cimg_forZ(img, z) {
    // z is the z-coordinate, ranging from 0 to img.depth() - 1.
}
</code></pre>
<ul>
<li><strong>cimg_forC(img,c)</strong>: Iterates over the channels (spectrum) of an image.</li>
</ul>
<pre><code class="language-cpp">cimg_forC(img, c) {
    // c is the channel index, ranging from 0 to img.spectrum() - 1.
}
</code></pre>
<ul>
<li><strong>cimg_forXY(img,x,y)</strong>: Iterates over both the width and height of an image.</li>
</ul>
<pre><code class="language-cpp">cimg_forXY(img, x, y) {
    // Do something with x and y coordinates.
}
</code></pre>
<ul>
<li><strong>cimg_forXYZ(img,x,y,z)</strong>: Iterates over width, height, and depth of a 3D image.</li>
</ul>
<pre><code class="language-cpp">cimg_forXYZ(img, x, y, z) {
    // Do something with x, y, and z coordinates.
}
</code></pre>
<ul>
<li><strong>cimg_forXYZC(img,x,y,z,c)</strong>: Iterates over all dimensions, including channels.</li>
</ul>
<pre><code class="language-cpp">cimg_forXYZC(img, x, y, z, c) {
    // Do something with x, y, z coordinates and channel c.
}
</code></pre>
<h2 id="7-drawing-blocks">7. Drawing Blocks</h2>
<p><code>blocks</code> is a vector of <code>(x0, y0, x1, y1)</code> coordinates. In the following code, we iterate through each block. We use <code>get_crop()</code> and <code>resize()</code> the cropped image to 1x1 pixels, which is the average color of the block. Then we draw a rectangle using the <code>draw_rectangle()</code> method.</p>
<pre><code class="language-cpp">// Rendering of the decomposition.
CImg&lt;unsigned char&gt; res(img.width(), img.height(), 1, 3, 0);
CImg&lt;int&gt; coords(img.width(), img.height(), 1, 4, 0);
cimglist_for(blocks, l)
{
    CImg&lt;int&gt; &amp;block = blocks[l];
    int
        x0 = block[0],
        y0 = block[1],
        x1 = block[2],
        y1 = block[3];
    CImg&lt;unsigned char&gt; color = img.get_crop(x0, y0, x1, y1).resize(1, 1, 1, 3, 2);
    res.draw_rectangle(x0, y0, x1, y1, color.data(), 1);
    coords.draw_rectangle(x0, y0, x1, y1, block.data());
}
</code></pre>
<p>There are two <code>CImg</code> objects here:</p>
<ul>
<li><code>res</code>: This is the final image that will be displayed. It is initialized to all black pixels.</li>
<li><code>coords</code>: This maps each pixel to the block it belongs to. It will be used later for user interaction.</li>
</ul>
<pre><code class="language-cpp">// Adding black borders.
res.mul(1 - (res.get_shift(1, 1, 0, 0, 0) - res).norm().cut(0, 1));
</code></pre>
<p>This above is a clever way to add black borders:</p>
<h3 id="part-1-edge-detection">Part 1: Edge Detection</h3>
<p>The first part of the expression is a kind of high-pass edge detection filter that calculates the difference between adjacent pixels in the image, thereby emphasizing sharp changes or edges. The expression for this part is:</p>
<p>
<script type="math/tex; mode=display">
\text{mask}(x, y) = \left(1 - \min\left(1, \max\left(0, \|res(x, y) - res(x - 1, y - 1)\|\right)\right)\right)
</script>
</p>
<p>Here, <script type="math/tex">\|res(x, y) - res(x - 1, y - 1)\|</script> calculates the difference between adjacent pixels. By using the <code>min</code> and <code>max</code> functions, this difference is clipped to the range <script type="math/tex">[0, 1]</script>, with 0 representing no change (no edge) and 1 representing a large change (an edge).</p>
<ul>
<li>
<p><code>res</code>
<img alt="lightouse res" src="../results/02/lighthouse_res.png" /></p>
</li>
<li>
<p><code>mask</code>
<img alt="lighthouse mask" src="../results/02/lighthouse_mask.png" /></p>
</li>
</ul>
<h3 id="part-2-multiplication">Part 2: Multiplication</h3>
<p>The second part of the expression involves multiplying the original pixel value with the edge value obtained in Part 1. This has the effect of enhancing the detected edges in the image. The expression for this part is:</p>
<p>
<script type="math/tex; mode=display">\text{result}(x, y) = res(x, y) \cdot \text{mask}(x, y)</script>
</p>
<ul>
<li>Block Decomposition
<img alt="lighthouse blocks" src="../results/02/lighthouse_blocks.png" /></li>
</ul>
<p>The book also propose two other ways to render the borders: <code>CImg&lt;unsigned char&gt;::fill()</code> and <code>cimg_for3x3</code>.</p>
<h2 id="8-gui">8. GUI</h2>
<p>The <code>CImgDisplay</code> class is used to create a window and display an image. It has the following constructor:</p>
<pre><code class="language-cpp">CImgDisplay disp(const CImg&lt;T&gt;&amp; img, const char* title = 0, const int normalization_type = 3);
</code></pre>
<p>The normalization type is used to specify how the image is normalized when displayed. The following table shows the different options:</p>
<table>
<thead>
<tr>
<th>Normalization Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>No normalization applied.</td>
</tr>
<tr>
<td>1</td>
<td>Automatic linear normalization to the <script type="math/tex">[0, 255]</script> range.</td>
</tr>
<tr>
<td>2</td>
<td>A one-time linear normalization with parameters calculated at the first display. These are then reused for subsequent images in the same window. Ideal for preserving consistent gray levels.</td>
</tr>
<tr>
<td>3</td>
<td>Default automatic mode, with behavior depending on the type.</td>
</tr>
</tbody>
</table>
<p>The following code creates a window and displays the image <code>res</code>:</p>
<pre><code class="language-cpp">// Start the interactive viewer.
CImgDisplay disp(res, &quot;CImg Tutorial: Block Decomposition&quot;, 0);
unsigned char white[] = {255, 255, 255}, black[] = {0, 0, 0};
while (!disp.is_closed() &amp;&amp; !disp.is_keyESC())
{
    int
        x = disp.mouse_x(),
        y = disp.mouse_y();
    if (x &gt;= 0 &amp;&amp; y &gt;= 0)
    {
        // Get the coordinates of the block under the mouse position.
        int
            x0 = coords(x, y, 0),
            y0 = coords(x, y, 1),
            x1 = coords(x, y, 2), y1 = coords(x, y, 3),
            xc = (x0 + x1) / 2, yc = (y0 + y1) / 2;

        // Get the block and its gradient.
        CImg&lt;unsigned char&gt;
            pImg = img.get_crop(x0, y0, x1, y1).resize(128, 128, 1, 3, 1),
            pGrad = normGrad.get_crop(x0, y0, x1, y1).resize(128, 128, 1, 3, 1).normalize(0, 255).map(CImg&lt;unsigned char&gt;::hot_LUT256());

        // Display the block and its gradient.
        (+res).
        draw_text(10, 3, &quot;X, Y = %d, %d&quot;, white, 0, 1, 24, x, y).
        draw_rectangle(x0, y0, x1, y1, black, 0.25f).
        draw_line(74, 109, xc, yc, white, 0.75, 0xCCCCCCCC).
        draw_line(74, 264, xc, yc, white, 0.75, 0xCCCCCCCC).
        draw_rectangle(7, 32, 140, 165, white).
        draw_rectangle(7, 197, 140, 330, white).
        draw_image(10, 35, pImg).
        draw_image(10, 200, pGrad).
        display(disp);
    }
    disp.wait(); // Wait for an user event
    if (disp.is_resized())
        disp.resize(disp);
}
</code></pre>
<p>Read a book for more details. Note that <code>(+res)</code> is a trick used to make a copy of the image <code>res</code> without creating a new object.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../01_getting_started/" class="btn btn-neutral float-left" title="1. Getting Started"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../03_point_processing/" class="btn btn-neutral float-right" title="3. Point Processing Transformations">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright &copy; 2023 Tony Fu</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/tonyfu97/Digital-Image-Processing" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../01_getting_started/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../03_point_processing/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
